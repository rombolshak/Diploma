\section{Обработка полученного ключа}
Любой протокол квантового распределения частей состоит из двух частей: квантовой и классической \cite{gisin2002Quacry}. Квантовая часть включает в себя собственно передачу квантовых состояний, манипуляции над ними и измерения, и проводится с использованием квантового канала связи. Классическая часть проводится через открытый аутентичный классический канал (то есть такой, который злоумышленник может прослушивать, но не может изменить передаваемые данные) и включает в себя коррекцию ошибок и усиление секретности. 

\subsection{Коррекция ошибок}
Результатом квантовой части является так называемый <<сырой>> ключ на обеих сторонах квантового канала. Этот ключ должен быть очищен от всех ошибок, неизбежно возникающих в процессе. Ошибки могут быть как внутренними (из-за низкой эффективности самого протокола), так и внешними, исходящими как от физических недостатков используемой аппаратуры, так и от действий подслушивателя. Внутренние ошибки исправить проще, что обычно и делается по ходу протокола путем передачи через открытый канал информации о начальном состоянии. К примеру, в протоколе BB84\cite{bb84} половина от всей переданной последовательности состояний будет измерена Бобом в базисе, не совпадающим с тем, в каком их готовила Алиса. Это приведет к тому, что 50\% полученных бит в итоге не войдут в секретный ключ. В реальности же, оставшиеся биты все еще будут подвержены ошибкам, возникших либо со стороны аппаратуры, либо из-за действий злоумышленника, что в принципе неразличимо. В дальнейшем будет предполагаться, что используемая аппаратура идеальна, а все ошибки возникают исключительно из-за воздействия Евы.

В \cite{information_reconcilation} продемонстрировано существование оптимального, хоть и не эффективного, протокола, оставляющего минимальное количество информации подслушивателю. На практике же стандартом де-факто для всех протоколов квантового распределения ключей является протокол коррекции ошибок \textit{Cascade}.

\subsubsection{Протокол Cascade}
\begin{enumerate}
  \item Работа протокола происходит в несколько проходов, число которых определяется сторонами до начала процесса. У каждой из сторон имеется своя битовая строка: $A = A_1,\dots,A_n$ и $B = B_1,\dots,B_n$ (где $B_i,A_i \in \{0, 1\}$) у Алисы и Боба соответственно.
  
  \item На каждом проходе $i$ Алиса и Боб выбирают значение $k_i$ и случайную функцию $f_i: [1..n]\rightarrow[1..\ceil{\frac{n}{k_i}}]$. Биты, чья позиция находится в множестве $K^i_j = \{l~|~f_i(l) = j\}$ формируют блок $j$ в проходе $i$. Таким образом, строка каждого из участников перемешивается случайно выбранным образом и разбивается на блоки размера $k_i$.
  
  \item Алиса посылает Бобу четности каждого блока текущего прохода: 
  $$ a_j = \bigoplus_{l \in K^i_j} A_l,~ 1 \leq j \leq \ceil[\Big]{\frac{n}{k_i}} $$
  
  \item Боб вычисляет свои $b_j$ таким же образом и сравнивает их с полученными $a_j$. 
  
  \item Множество блоков, в которых содержится нечетное число ошибок, обозначим $\mathcal{E}$.
  Изначально в это множество заносятся блоки, четности которых не совпали: ($b_j \neq a_j $).
  
  \item\label{while_condition} Если $\mathcal{E} \neq \emptyset$, выбирается блок наименьшего размера из $\mathcal{E}$, иначе проход считается завершенным.
  
  \item Для выбранного блока проводится дихотомический поиск ошибки:
  \begin{enumerate}
    \item Алиса посылает Бобу четность первой половины бит указанного блока.
    \item Боб сравнивает полученные данные со своими. Если четности не совпали, то в первой половине блока находится нечетное число ошибок; если совпали~--- во второй.
    \item Процесс повторяется с той половиной блока, о которой теперь известно, что в ней находится нечетное число ошибок.
    \item В конце концов будет найдена одна позиция, значения строк в которой у Алисы и Боба различаются.
  \end{enumerate}
  
  \item В результате поиска Боб обнаружит позицию $l$ такую, что $B_l \neq A_l$ и исправит свое значение. 
  
  \item Все блоки $K^u_v$ для $1 \leq u < i$ такие, что $l \in K^u_v$ (то есть содержащие в себе только что исправленную позицию) будут теперь иметь нечетное число ошибок. Обозначим множество этих блоков за $\mathcal{K}$
  
  \item Множество $\mathcal{E}$ изменяется следующим образом: для каждого блока $K \in \mathcal{K}$, если $K \in \mathcal{E}$, происходит его удаление из $\mathcal{E}$, в противном случае блок $K$ добавляется к $\mathcal{E}$. Формально говоря, $\mathcal{E}' = \mathcal{E} \bigtriangledown \mathcal{K} = (\mathcal{E} \cup \mathcal{K}) \setminus (\mathcal{E} \cap \mathcal{K})$.
  
  \item Дальнейшее выполнение продолжается с шага \ref{while_condition} и множеством $\mathcal{E}'$ в качестве $\mathcal{E}$.

\end{enumerate}
На практике обычно используется 4 прохода, размеры блоков в каждом следующем проходе удваиваются, а начальный размер блока выбирается из соображений максимизации количества исправленных ошибок в первом проходе, что зависит от предполагаемой величины ошибок $p$.
